# Real Code Examples from Your Project

This document shows actual code from your project with detailed explanations of JavaScript and TypeScript concepts.

---

## 1. TypeScript Generics in Action

### Example: `fetcher.ts` - Generic Function

```typescript
export const fetcher = <T>(
  url: string,
  options?: {
    method: METHODS;
    body?: Record<string, unknown>;
    headers?: RequestInit["headers"];
    signal?: AbortSignal;
  },
): Promise<T> => {
  // ... implementation
  return fetch(url, config)
    .then(handleError)
    .then(toJSON);
};
```

**What's happening:**
- `<T>` is a **generic type parameter** - it can be any type
- `Promise<T>` means "returns a Promise that resolves to type T"
- When you call it, TypeScript infers the type:

```typescript
// Usage in hooks.ts
const data = await fetcher<VenueCheckListResponse>(url, {
  method: METHOD.GET,
});
// TypeScript knows 'data' is VenueCheckListResponse
```

**Why use generics?**
- One function works with any type
- Type safety - TypeScript knows the return type
- No need to write separate functions for each type

---

## 2. Array Methods - Real Usage

### Example: `VenueChecklist.tsx` - Checking for Changes

```typescript
const basicFields = [venueName, contactName, phoneNumber, email];
const hasBasicContent = basicFields.some(
  (field) =>
    field !== null && field !== undefined && String(field).trim() !== "",
);
```

**Breaking it down:**
- `basicFields` - array of values
- `.some()` - returns `true` if **ANY** element passes the test
- Arrow function `(field) => ...` - test function
- `String(field).trim() !== ""` - checks if field has content

**Other array methods in your code:**

```typescript
// .find() - Find first matching element
const originalAnswer = originalQuestions.find(
  (q) => q.id === answer.questionId,
);

// .map() - Transform array
const names = users.map(user => user.name);

// .filter() - Create new array with filtered items
const activeItems = items.filter(item => item.isActive);
```

---

## 3. Object Destructuring - Multiple Examples

### Example 1: Simple Destructuring

```typescript
// From VenueChecklist.tsx
const { venueName, contactName, phoneNumber, email, questions } = venueData;
```

**What this does:**
- Extracts properties from `venueData` object
- Creates variables with same names
- Equivalent to:
```typescript
const venueName = venueData.venueName;
const contactName = venueData.contactName;
// ... etc
```

### Example 2: Destructuring with Renaming

```typescript
// From App.tsx
const { data: venueData, isFetching: isVenueChecklistFetching } = useViewVenueCheckList(id);
```

**What this does:**
- `data` is renamed to `venueData`
- `isFetching` is renamed to `isVenueChecklistFetching`

### Example 3: Nested Destructuring

```typescript
const {
  setHasUnsavedChanges,
  setHasAnyFieldContent,
  showReloadModal,
} = reloadHandlerContext;
```

---

## 4. React Hooks - useState Pattern

### Example: `VenueChecklist.tsx`

```typescript
const [activeTab, setActiveTabState] = useState(0);
const [totalTabs, setTotalTabs] = useState(0);
const [isConfirmationOpen, setIsConfirmationOpen] = useState(false);
const [selectedVersionId, setSelectedVersionId] = useState<number | undefined>(undefined);
```

**Pattern:**
- `useState(initialValue)` returns `[value, setter]`
- First element: current state value
- Second element: function to update state
- TypeScript type: `useState<number | undefined>(undefined)`

**Updating state:**
```typescript
setActiveTabState(5);  // Direct value
setActiveTabState(prev => prev + 1);  // Based on previous value
```

---

## 5. useEffect Hook - Side Effects

### Example: `useDebounce.ts`

```typescript
useEffect(() => {
  const timer = setTimeout(() => {
    setDebouncedValue(value);
  }, delay);

  return () => {
    clearTimeout(timer);
  };
}, [value, delay]);
```

**What's happening:**
1. **Setup**: Creates a timer when component mounts or dependencies change
2. **Effect**: After `delay` milliseconds, updates `debouncedValue`
3. **Cleanup**: Returns a function that clears the timer
4. **Dependencies**: `[value, delay]` - effect runs when these change

**Why cleanup?**
- Prevents memory leaks
- Cancels pending operations when component unmounts
- Prevents state updates on unmounted components

---

## 6. Custom Hooks - Reusable Logic

### Example: `useDebounce.ts`

```typescript
function useDebounce<T>(value: T, delay = 500): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => clearTimeout(timer);
  }, [value, delay]);

  return debouncedValue;
}
```

**How it works:**
1. Takes a `value` and `delay` (defaults to 500ms)
2. Returns a debounced version of the value
3. Generic `<T>` works with any type

**Usage:**
```typescript
const [searchTerm, setSearchTerm] = useState("");
const debouncedSearch = useDebounce(searchTerm, 500);

// searchTerm updates immediately
// debouncedSearch updates 500ms after user stops typing
```

---

## 7. Redux Toolkit - State Management

### Example: `clientSlice.ts`

```typescript
const clientSlice = createSlice({
  name: "client",
  initialState: {
    activeClient: {
      endPointUrl: null,
      logo: null,
      name: null,
    },
  },
  reducers: {
    setActiveClient: (state, action: PayloadAction<ClientState>) => {
      state.activeClient = action.payload.activeClient;
    },
  },
});

export const { setActiveClient } = clientSlice.actions;
export default clientSlice.reducer;
```

**What's happening:**
1. **createSlice**: Creates a slice of Redux state
2. **initialState**: Starting state
3. **reducers**: Functions that update state (pure functions)
4. **PayloadAction**: TypeScript type for action payload

**Using in component:**
```typescript
// Dispatch action
dispatch(setActiveClient({ activeClient: newClient }));

// Read state
const activeClient = useSelector((state: RootState) => state.client.activeClient);
```

---

## 8. React Query - Data Fetching

### Example: `hooks.ts`

```typescript
export const useViewVenueCheckList = (
  vendorVenueId: number,
  enabled = true,
) => {
  return useQuery({
    queryKey: ["venueChecklist", vendorVenueId],
    queryFn: () => fetcher<VenueCheckListResponse>(url, {
      method: METHOD.GET,
    }),
    enabled,
  });
};
```

**What's happening:**
- **queryKey**: Unique identifier for this query (used for caching)
- **queryFn**: Function that fetches data
- **enabled**: Whether to run the query automatically

**Using in component:**
```typescript
const {
  data: venueData,
  isFetching: isVenueChecklistFetching,
  refetch: refetchChecklist,
} = useViewVenueCheckList(vendorId, selectedVersionId);
```

**Benefits:**
- Automatic caching
- Loading states
- Error handling
- Refetching
- Background updates

---

## 9. Type Definitions - Complex Types

### Example: `dropdown.type.ts`

```typescript
export type OptionType = {
  value: number;
  label: string;
  labelInfo?: string;  // Optional property
  iconSrc?: string;
  isActive?: boolean;
  IconComponent?: React.FunctionComponent<React.SVGProps<SVGSVGElement>>;
  isDisabled?: boolean;
  valueString?: string;
  clientStatus?: ClientStatusLabel;
};
```

**Key concepts:**
- `?` makes properties optional
- `React.FunctionComponent` - React component type
- `React.SVGProps<SVGSVGElement>` - Props for SVG elements

**Usage:**
```typescript
const option: OptionType = {
  value: 1,
  label: "Option 1",
  // labelInfo is optional, so we can omit it
};
```

---

## 10. Error Handling - Try/Catch

### Example: `fetcher.ts`

```typescript
.catch((error) => {
  if (
    error.name === "TypeError" &&
    error.message &&
    error.message.includes("fetch")
  ) {
    console.error("Network error:", error);
    throw new Error(
      "Network connection failed. Please check your internet connection and try again.",
    );
  }
  throw error;
});
```

**What's happening:**
1. Catches errors from fetch
2. Checks if it's a network error
3. Throws a user-friendly error message
4. Re-throws other errors

**Type checking:**
```typescript
if (error instanceof Error) {
  console.log(error.message);
}
```

---

## 11. Optional Chaining & Nullish Coalescing

### Example: `VenueChecklist.tsx`

```typescript
const vendorId =
  useSelector((state: RootState) => state.venueVendorReducer.vendorId) ??
  undefined;
```

**Breaking it down:**
- `??` (nullish coalescing): Returns right side if left is `null` or `undefined`
- `?.` (optional chaining): Safely accesses nested properties

**More examples:**
```typescript
// Optional chaining
const email = user?.profile?.email;  // Won't crash if user is null

// Nullish coalescing
const name = userName ?? "Guest";  // Default to "Guest" if userName is null/undefined
const count = items?.length ?? 0;  // Default to 0 if items is null/undefined
```

---

## 12. Spread Operator - Object Merging

### Example: `fetcher.ts`

```typescript
const config: RequestInit = {
  ...opt,
  headers: {
    ...defaultHeaders,
    ...options?.headers,
  },
};
```

**What's happening:**
- `...opt` - Spreads all properties from `opt`
- `...defaultHeaders` - Spreads default headers
- `...options?.headers` - Spreads custom headers (overrides defaults)

**Result:**
```typescript
// If options?.headers = { "Custom-Header": "value" }
// Result:
{
  method: "POST",
  body: "...",
  headers: {
    Authorization: "Bearer token",
    "Content-Type": "application/json",
    "Custom-Header": "value",  // Custom header added
  }
}
```

---

## 13. Type Assertions

### Example: `main.tsx`

```typescript
const rootElement = document.getElementById("root") as HTMLElement;
```

**What's happening:**
- `getElementById` returns `HTMLElement | null`
- `as HTMLElement` tells TypeScript: "I know this is HTMLElement"
- Used when you're certain of the type

**Alternative:**
```typescript
const rootElement = document.getElementById("root");
if (rootElement) {
  // TypeScript knows rootElement is HTMLElement here
}
```

---

## 14. Conditional Rendering

### Example: `VenueChecklist.tsx`

```typescript
{isLoading && <Loader />}
{error ? <Error /> : <Content />}
{items.length > 0 && items.map(item => <Item key={item.id} />)}
```

**Patterns:**
- `condition && <Component />` - Render if true
- `condition ? <A /> : <B />` - Ternary operator
- `items.length > 0 && ...` - Guard clause

---

## 15. useRef Hook - Mutable Values

### Example: `VenueChecklist.tsx`

```typescript
const venueChecklistDataRef = useRef(venueChecklistData);
venueChecklistDataRef.current = venueChecklistData;
```

**Why useRef?**
- Stores mutable value that doesn't trigger re-renders
- Persists across renders
- Can access current value in callbacks

**Common use cases:**
1. Store previous values
2. Access DOM elements
3. Store timer IDs
4. Keep mutable values without re-renders

---

## 16. Function Types

### Example: `dropdown.type.ts`

```typescript
export type Props = SelectProps<OptionType> & {
  onBlur?: (e: { target: { value: number } }) => void;
  handleApply?: (value: PropsValue<unknown>) => void;
  setValue?: (value: PropsValue<unknown>) => void;
};
```

**What's happening:**
- `(e: { target: { value: number } }) => void` - Function type
- Takes an event object, returns nothing (void)
- `?` makes it optional

**Usage:**
```typescript
const handleBlur = (e: { target: { value: number } }) => {
  console.log(e.target.value);
};

// Pass to component
<Dropdown onBlur={handleBlur} />
```

---

## 17. Enums

### Example: `enums.ts`

```typescript
enum APP_MODULE {
  CLIENT = "Client",
  FA = "FunctionalArea",
  ROLE = "Role",
  PERMISSION = "Permission",
}
```

**What's happening:**
- Creates a set of named constants
- Type-safe way to use constants
- Prevents typos

**Usage:**
```typescript
const module = APP_MODULE.CLIENT;  // "Client"
// TypeScript autocompletes available values
```

---

## 18. Async/Await Pattern

### Example: `fetcher.ts`

```typescript
const handleError = async (response: Response) => {
  if (response.status === 401) {
    window.open(`${location.origin}/login`, "_self");
  }

  if (!response.ok) {
    try {
      const errorBody = await response.json();
      throw new Error(errorBody?.message || "Unknown error");
    } catch (parseError) {
      throw new Error("Network error");
    }
  }

  return response;
};
```

**What's happening:**
- `async` function can use `await`
- `await` pauses execution until Promise resolves
- `try/catch` handles errors

**Comparison:**
```typescript
// Promise chains
fetch(url)
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error(error));

// Async/await (cleaner)
try {
  const response = await fetch(url);
  const data = await response.json();
  console.log(data);
} catch (error) {
  console.error(error);
}
```

---

## 19. Module Exports

### Example: Multiple files

**Named exports:**
```typescript
// hooks.ts
export const useDebounce = () => { };
export type OptionType = { };

// Import
import { useDebounce, type OptionType } from "./hooks";
```

**Default export:**
```typescript
// App.tsx
export default App;

// Import
import App from "./App";
```

**Mixed:**
```typescript
// clientSlice.ts
export const { setActiveClient } = clientSlice.actions;
export default clientSlice.reducer;

// Import
import clientReducer, { setActiveClient } from "./clientSlice";
```

---

## 20. Type Guards

### Example: Error handling

```typescript
if (error instanceof Error) {
  console.log(error.message);
}

// Custom type guard
function isString(value: unknown): value is string {
  return typeof value === "string";
}

if (isString(value)) {
  // TypeScript knows value is string here
  console.log(value.toUpperCase());
}
```

**Why use type guards?**
- Narrow types in TypeScript
- Type-safe runtime checks
- Better IntelliSense

---

## Summary: Key Patterns in Your Project

1. **TypeScript Generics** - Reusable typed functions
2. **Array Methods** - `.map()`, `.filter()`, `.find()`, `.some()`
3. **Destructuring** - Extract object/array values
4. **React Hooks** - `useState`, `useEffect`, `useMemo`, `useCallback`, `useRef`
5. **Redux Toolkit** - Global state management
6. **React Query** - Server state & data fetching
7. **Custom Hooks** - Reusable logic
8. **Type Definitions** - Interfaces and types
9. **Error Handling** - Try/catch, error types
10. **Modern JS** - Optional chaining, nullish coalescing, spread operator

---

## Practice: Read These Files

1. `src/hook/useDebounce.ts` - Custom hook pattern
2. `src/shared/fetcher.ts` - Generic functions, error handling
3. `src/store/client/clientSlice.ts` - Redux pattern
4. `src/pages/EngagementDetails/Venue/hooks.ts` - React Query usage
5. `src/App.tsx` - Component composition, providers
6. `src/components/Dropdown/dropdown.type.ts` - Type definitions

Each file demonstrates multiple concepts working together!


